Part 1: Flutter Kiosk App (Project "Gemini") — Full Development Plan
Project Mission: To build a highly reliable, single-purpose kiosk application for a dedicated Android/iOS device. The app's sole function is to securely scan employee QR codes, capture verification data (photo, location), and log attendance. It must be robust, user-friendly, and capable of functioning with intermittent internet connectivity.

1. Core Architecture \& Principles
   State Management: We will use Riverpod. It provides compile-time safety, is easy to reason about, and is excellent for dependency injection, allowing us to provide different services (like a real vs. a mock Supabase client) cleanly.
   Folder Structure: A feature-first, layered approach.
   code
   Code
   lib/
   ├── core/                  # Core utilities, constants, themes
   ├── data/                  # Data sources and repositories
   │   ├── models/            # Data models (Employee, Log)
   │   ├── providers/         # Supabase client, other providers
   │   └── services/          # API calls, local DB access
   ├── features/              # Main app features/screens
   │   ├── registration/      # One-time device setup
   │   ├── kiosk/             # The main scanning screen and its logic
   │   └── sync/              # Background data synchronization
   └── main.dart              # App entry point
   Navigation: Since the app is simple (likely only two main screens), a basic Navigator 2.0 or a simple routing solution will suffice.
2. Required Dependencies (pubspec.yaml)
   code
   Yaml
   dependencies:
3. &nbsp; flutter:
4. &nbsp;   sdk: flutter
5. &nbsp; supabase\_flutter: ^2.0.0
6. &nbsp; riverpod\_flutter: ^2.0.0
7. &nbsp; mobile\_scanner: ^3.0.0
8. &nbsp; camera: ^0.10.0
9. &nbsp; geolocator: ^10.0.0
10. &nbsp; image: ^4.0.0
11. &nbsp; # --- Replaced Isar with Hive ---
12. &nbsp; hive: ^2.2.3
13. &nbsp; hive\_flutter: ^1.1.0
14. &nbsp; # --- End of Replacement ---
15. &nbsp; path\_provider: ^2.0.0
16. &nbsp; connectivity\_plus: ^4.0.0
17. &nbsp; flutter\_secure\_storage: ^8.0.0
18. &nbsp; device\_info\_plus: ^9.0.0 # For getting unique device ID
19. 
20. dev\_dependencies:
21. &nbsp; # --- For Hive Code Generation ---
22. &nbsp; hive\_generator: ^2.0.0
23. &nbsp; build\_runner: ^2.4.0
24. &nbsp; # --- End of Generation ---



Detailed Feature \& Page Implementation Plan
Step 0: App Initialization (main.dart) - Updated

Logic: On startup, the app must decide which screen to show.

Initialize Supabase.

Initialize Hive: Use await Hive.initFlutter() to set up the storage directory.

Register Hive Adapter: Create a PendingLogAdapter for your offline data model (this is auto-generated by build\_runner) and register it with Hive.registerAdapter().

Use flutter\_secure\_storage to check if a device\_unique\_id is saved.

If found, navigate to the Kiosk Home Screen.

If not found, navigate to the Device Registration Screen.



Step 1: Device Registration Screen
Purpose: A one-time setup process for an administrator to register the kiosk as a trusted device.
UI: A simple form containing:
Email and Password fields for admin login.
A "Device Name" text field (e.g., "Main Entrance Kiosk").
A "Register Device" button.
Logic (on button press):
Authenticate the admin using Supabase Auth (supabase.auth.signInWithPassword).
If successful, fetch the device's unique hardware ID (using a package like device\_info\_plus).
Get the device's current GPS coordinates using geolocator. This sets the fixed "office location" for this device.
Call Supabase to insert a new record into the devices table with the name, unique ID, and fixed location.
Securely save the device\_unique\_id on the device using flutter\_secure\_storage.
Navigate to the Kiosk Home Screen, removing the registration screen from the navigation stack.


Step 2: Kiosk Home Screen
Purpose: The main, always-on screen for daily attendance logging.
State Management (Riverpod): This screen will be driven by a StateNotifierProvider that manages the Kiosk's state (e.g., KioskState.ready, KioskState.verifying, KioskState.success, KioskState.failure).
UI:
A full-screen live preview from the front-facing camera.
A central overlay with a semi-transparent QR code scanning area.
A status text overlay at the top (e.g., "Please Scan Your ID Card").
A small icon indicating internet connectivity status.
Core Logic (The Verification Flow):
Detection: mobile\_scanner detects a QR code and returns the employee\_id string.
State Change: The state immediately transitions to KioskState.verifying. The QR scanner is paused. The UI overlay changes to "Verifying... Please look at the camera."
Capture Data:
Simultaneously trigger camera.takePicture() to capture the live photo.
And geolocator.getCurrentPosition() to get the current GPS coordinates.
Process Image: Take the captured image file, use the image package to resize it and encode it as a high-quality WebP file (target < 20kb).
Check Connectivity: Use the connectivity\_plus package.
If ONLINE:
a. Upload the compressed WebP image to the attendance-photos bucket in Supabase Storage.
b. On successful upload, get the public URL of the photo.
c. Call the log\_verified\_attendance RPC in Supabase, passing the employee\_id, locally stored device\_unique\_id, photo URL, and GPS coordinates.
d. The RPC returns a success or error message.
If OFFLINE:
a. Convert the compressed image bytes to a Base64 string.
b. Create a local "pending log" object containing the employee\_id, timestamp, Base64 photo string, and location.
c. Save this object to the local Isar database.
d. Assume success for the user (to keep the line moving). The UI will show a generic "Log Saved" message.
Provide Feedback:
On success (from RPC or offline save), transition to KioskState.success. Display the success message from the RPC (e.g., "Welcome, John Doe!") with a large green checkmark for 3-4 seconds.
On failure (from RPC), transition to KioskState.failure. Display the error message (e.g., "Employee not found") with a red 'X' for 3-4 seconds.
Reset: After the feedback delay, transition the state back to KioskState.ready and resume the mobile\_scanner.


Step 3: The Core Scanning \& Verification Flow - Updated

The initial flow (scan, capture photo, get location) is the same. The change is in how the app handles an offline scenario.

Check Connectivity: Use the connectivity\_plus package.

If ONLINE:

(Unchanged) Upload the compressed image to Supabase Storage, then call the log\_verified\_attendance RPC with the photo URL and other data.

If OFFLINE (The Hive Approach):

a. Do not convert the image to Base64. Instead, save the compressed image file (as Uint8List or bytes) to a temporary directory on the device using path\_provider. Keep the file path.

b. Create a PendingLog object. This local model will contain fields like employeeId, timestamp, latitude, longitude, and importantly, the localImagePath.

c. Save to Hive: Open your "pending\_logs" box (await Hive.openBox('pending\_logs')) and add the new PendingLog object using box.add(newLog).

d. Provide User Feedback: Assume success for the user to keep the line moving. The UI will show a generic "Log Saved. Will sync when online." message.

Step 4: Background Sync Service - Updated

Purpose: To reliably upload offline-saved logs and their photos.

Logic:

Create a service that listens to the connectivity\_plus stream.

When the connection state changes to online, trigger a sync function.

The sync function will:

a. Open the pending\_logs Hive box.

b. If the box is empty, do nothing.

c. If the box has items, loop through them using their keys (for (var key in box.keys)).

d. For each PendingLog object:

i. Read the image file from the localImagePath stored in the log.

ii. Upload this image file to Supabase Storage.

iii. On successful upload, get the photo URL and call the log\_verified\_attendance RPC with the log's data.

iv. On successful RPC call, delete the log from the local queue using box.delete(key) and delete the temporary image file.

v. If any step fails (e.g., upload fails), stop and retry later, leaving the log in the Hive box.



